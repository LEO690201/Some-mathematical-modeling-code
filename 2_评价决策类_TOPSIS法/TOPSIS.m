%% 1.判断是否需要正向化
%A=[9,10,175,120;8,7,164,80;6,3,157,90]
X=input('指标矩阵A=');
[n,m]=size(X);
disp(['共有' num2str(n) '个评价对象,' num2str(m) '个评价指标']);%字符串拼接,使用[]
%num2str函数用于将数字转化为字符串,因为涉及到了字符串的拼接,因此需要用到该函数
Judge=input(['这' num2str(m) '个评价指标是否需要正向化(1表示需要，0表示不需要)：']);

if Judge==1
    Position=input('请输入需要正向化处理的指标所在列,例如第2,3,6三列需要处理,那么要输入[2,3,6]:  ');%[2,3,4]
    disp('请输入需要处理的这些列的指标类型(1:极小值,2:中间型,3:区间型)')
    Type=input('例如:第2列是极小型,第3列是区间型,第6列是中间型,就输入[1,3,2]: ');%[1,2,3]
    %注意:Position和Type是两个同维度的行向量
    for i=1:size(Position,2) %这里要对这些列分别处理,因此需要知道一共要处理的次数,即循环次数
        X(:,Position(i))=Positivization(X(:,Position(i)),Type(i),Position(i));
    %Positivization函数是自己定义的函数,作用是进行正向化,其一共接收三个参数
    %第一个参数是指标矩阵需要正向化处理的那一列向量X(:,Position(i)),即需要处理的指标矩阵
    %第二个参数是指标类型,即1:极小值型,2:中间型,3:区间型
    %第三个参数是指标所在列号,即Position(i)
    %该函数有一个返回值,它返回正向化之后的指标,我们可以将其直接赋值给我们原始要处理的那一列向量
    end
    disp('正向化处理之后的矩阵X=');
    disp(X)
end

%% 2.对正向化后的矩阵进行标准化
Z=X./repmat(sum(X.*X).^ 0.5 ,n,1);
disp('标准化之后的矩阵Z=');
disp(Z)

%% 3.计算与最大值的距离和最小值的距离,并计算出得分
D_P=sum([(Z-repmat(max(Z),n,1)).^2],2).^0.5;     %D+ 与最大值的距离
D_N=sum([(Z-repmat(min(Z),n,1)).^2],2).^0.5;     %D- 与最小值的距离
S=D_N./(D_N+D_P);                                %未归一化的TOPSIS得分
disp('最后得分为: ')
stand_S=100*S/sum(S)
[sorted_S,index]=sort(stand_S,'descend')    %排序,降序排列(默认为升序排列)


%% 新函数:

%num2str函数用于将数字转化为字符串,因为涉及到了字符串的拼接,因此需要用到该函数
%num2str(n)

%sort函数用于对矩阵中的元素进行排序,默认是升序排列,如果要降序排列,则需要加上'descend'参数
%[sorted_S,index]=sort(stand_S,'descend')
%其中,sorted_S是排序后的矩阵,index是排序后元素的索引,stand_S是未归一化的TOPSIS得分



